(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{175:function(t,n,s){"use strict";s.r(n);var e=s(0),a=Object(e.a)({},(function(){var t=this.$createElement;this._self._c;return this._m(0)}),[function(){var t=this,n=t.$createElement,s=t._self._c||n;return s("div",{staticClass:"content"},[s("h1",{attrs:{id:"js基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js基础"}},[t._v("#")]),t._v(" JS基础")]),t._v(" "),s("h2",{attrs:{id:"一、-类型及检测方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、-类型及检测方式"}},[t._v("#")]),t._v(" 一、 类型及检测方式")]),t._v(" "),s("h4",{attrs:{id:"_1-js内置类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-js内置类型"}},[t._v("#")]),t._v(" 1. JS内置类型")]),t._v(" "),s("p",[t._v("JavaScript 的数据类型有下图所示\n"),s("img",{attrs:{src:"/images/type.png",alt:""}}),t._v(" "),s("img",{staticStyle:{width:"50%",display:"block",margin:"0 auto"},attrs:{src:"/images/type.png"}})]),t._v(" "),s("div",{staticClass:"tip custom-block"},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("p",[t._v("其中，前 7 种类型为基础类型，最后 1 种（Object）为引用类型，也是你需要重点关注的，因为它在日常工作中是使用得最频繁，也是需要关注最多技术细节的数据类型")])]),t._v(" "),s("ul",[s("li",[t._v("JavaScript一共有8种数据类型，其中有7种基本数据类型：Undefined、Null、Boolean、Number、String、Symbol（es6新增，表示独一无二的值）和BigInt（es10新增）；")]),t._v(" "),s("li",[t._v("1种引用数据类型——Object（Object本质上是由一组无序的名值对组成的）。里面包含 function、Array、Date等。JavaScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一。")]),t._v(" "),s("li",[t._v("引用数据类型: 对象Object（包含普通对象-Object，数组对象-Array，正则对象-RegExp，日期对象-Date，数学函数-Math，函数对象-Function）"),s("br"),t._v(" "),s("strong",[t._v("原始数据类型")]),t._v("：基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。"),s("br"),t._v(" "),s("strong",[t._v("引用数据类型")]),t._v("：引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念；占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。\n"),s("strong",[t._v("JavaScript 中的数据是如何存储在内存中的？")])])]),t._v(" "),s("div",{staticClass:"tip custom-block"},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("p",[t._v("在 JavaScript 中，原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。")])]),t._v(" "),s("p",[t._v('在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间、栈空间、堆空间。其中的代码空间主要是存储可执行代码的，原始类型(Number、String、Null、Undefined、Boolean、Symbol、BigInt)的数据值都是直接保存在“栈”中的，引用类型(Object)的值是存放在“堆”中的。因此在栈空间中(执行上下文)，原始类型存储的是变量的值，而引用类型存储的是其在"堆空间"中的地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手流程。'),s("br"),t._v("\n在编译过程中，如果 JavaScript 引擎判断到一个闭包，也会在堆空间创建换一个“closure(fn)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存闭包中的变量。所以闭包中的变量是存储在“堆空间”中的。"),s("br"),t._v("\nJavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。因此需要“栈”和“堆”两种空间。"),s("br")]),t._v(" "),s("h4",{attrs:{id:"_2-数据类型检测"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-数据类型检测"}},[t._v("#")]),t._v(" 2. 数据类型检测")]),t._v(" "),s("h5",{attrs:{id:"（1）typeof"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#（1）typeof"}},[t._v("#")]),t._v(" （1）typeof")]),t._v(" "),s("div",{staticClass:"tip custom-block"},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("p",[t._v("typeof 对于原始类型来说，除了 null 都可以显示正确的类型")])]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("console.log(typeof 2);            // number\nconsole.log(typeof true);         // boolean\nconsole.log(typeof 'str');        // string\nconsole.log(typeof []);           // object []数组的数据类型在 typeof 中被解释为 object\nconsole.log(typeof function(){}); // function\nconsole.log(typeof {});           // object\nconsole.log(typeof undefined);    // undefined\nconsole.log(typeof null);         // object  null 的数据类型被 typeof 解释为 object\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br")])]),s("div",{staticClass:"tip custom-block"},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("p",[t._v("typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 instanceof")])]),t._v(" "),s("h5",{attrs:{id:"（2）instanceof"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#（2）instanceof"}},[t._v("#")]),t._v(" （2）instanceof")]),t._v(" "),s("div",{staticClass:"tip custom-block"},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("p",[t._v("instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype")])]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("console.log(2 instanceof Number);                    // false\nconsole.log(true instanceof Boolean);                // false \nconsole.log('str' instanceof String);                // false  \nconsole.log([] instanceof Array);                    // true\nconsole.log(function(){} instanceof Function);       // true\nconsole.log({} instanceof Object);                   // true    \n// console.log(undefined instanceof Undefined);\n// console.log(null instanceof Null);\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br")])]),s("ul",[s("li",[t._v("instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；")]),t._v(" "),s("li",[t._v("而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断")])]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("// 我们也可以试着实现一下 instanceof\nfunction instanceof(left, right) {\n    // 获得类型的原型\n    let prototype = right.prototype\n    // 获得对象的原型\n    left = left.__proto__\n    // 判断对象的类型是否等于类型的原型\n    while (true) {\n    \tif (left === null)\n    \t\treturn false\n    \tif (prototype === left)\n    \t\treturn true\n    \tleft = left.__proto__\n    }\n}\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br")])]),s("h5",{attrs:{id:"（3）constructor"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#（3）constructor"}},[t._v("#")]),t._v(" （3）constructor")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("console.log((2).constructor === Number); // true\nconsole.log((true).constructor === Boolean); // true\nconsole.log(('str').constructor === String); // true\nconsole.log(([]).constructor === Array); // true\nconsole.log((function() {}).constructor === Function); // true\nconsole.log(({}).constructor === Object); // true\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])]),s("div",{staticClass:"tip custom-block"},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("p",[t._v("这里有一个坑，如果我创建一个对象，更改它的原型，constructor就会变得不可靠了")])]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("function Fn(){};\n \nFn.prototype=new Array();\n \nvar f=new Fn();\n \nconsole.log(f.constructor===Fn);    // false\nconsole.log(f.constructor===Array); // true \n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br")])]),s("h5",{attrs:{id:"（4）object-prototype-tostring-call"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#（4）object-prototype-tostring-call"}},[t._v("#")]),t._v(" （4）Object.prototype.toString.call()")]),t._v(" "),s("div",{staticClass:"tip custom-block"},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("p",[t._v("toString() 是 Object 的原型方法，调用该方法，可以统一返回格式为 “[object Xxx]” 的字符串，其中 Xxx 就是对象的类型。对于 Object 对象，直接调用 toString() 就能返回 [object Object]；而对于其他对象，则需要通过 call 来调用，才能返回正确的类型信息。我们来看一下代码。")])]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('Object.prototype.toString({})       // "[object Object]"\nObject.prototype.toString.call({})  // 同上结果，加上call也ok\nObject.prototype.toString.call(1)    // "[object Number]"\nObject.prototype.toString.call(\'1\')  // "[object String]"\nObject.prototype.toString.call(true)  // "[object Boolean]"\nObject.prototype.toString.call(function(){})  // "[object Function]"\nObject.prototype.toString.call(null)   //"[object Null]"\nObject.prototype.toString.call(undefined) //"[object Undefined]"\nObject.prototype.toString.call(/123/g)    //"[object RegExp]"\nObject.prototype.toString.call(new Date()) //"[object Date]"\nObject.prototype.toString.call([])       //"[object Array]"\nObject.prototype.toString.call(document)  //"[object HTMLDocument]"\nObject.prototype.toString.call(window)   //"[object Window]"\n\n// 从上面这段代码可以看出，Object.prototype.toString.call() 可以很好地判断引用类型，\n甚至可以把 document 和 window 都区分开来。\n')])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br")])]),s("ul",[s("li",[t._v("实现一个全局通用的数据类型判断方法，来加深你的理解，代码如下")])]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('function getType(obj){\n  let type  = typeof obj;\n  if (type !== "object") {    // 先进行typeof判断，如果是基础数据类型，直接返回\n    return type;\n  }\n  // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果\n  return Object.prototype.toString.call(obj).replace(/^\\[object (\\S+)\\]$/, \'$1\');  // 注意正则中间有个空格\n}\n/* 代码验证，需要注意大小写，哪些是typeof判断，哪些是toString判断？思考下 */\ngetType([])     // "Array" typeof []是object，因此toString返回\ngetType(\'123\')  // "string" typeof 直接返回\ngetType(window) // "Window" toString返回\ngetType(null)   // "Null"首字母大写，typeof null是object，需toString来判断\ngetType(undefined)   // "undefined" typeof 直接返回\ngetType()            // "undefined" typeof 直接返回\ngetType(function(){}) // "function" typeof能判断，因此首字母小写\ngetType(/123/g)      //"RegExp" toString返回\n')])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br")])]),s("h5",{attrs:{id:"小结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),s("p",[s("strong",[t._v("typeof")])]),t._v(" "),s("ul",[s("li",[t._v("直接在计算机底层基于数据类型的值（二进制）进行检测")]),t._v(" "),s("li",[t._v("typeof null为object 原因是对象存在在计算机中，都是以000开始的二进制存储，所以检测出来的结果是对象")]),t._v(" "),s("li",[t._v("typeof 普通对象/数组对象/正则对象/日期对象 都是object")]),t._v(" "),s("li",[t._v("typeof NaN === 'number'")])]),t._v(" "),s("p",[s("strong",[t._v("instanceof")])]),t._v(" "),s("ul",[s("li",[t._v("检测当前实例是否属于这个类的")]),t._v(" "),s("li",[t._v("底层机制：只要当前类出现在实例的原型上，结果都是true")]),t._v(" "),s("li",[t._v("不能检测基本数据类型")])]),t._v(" "),s("p",[s("strong",[t._v("constructor")])]),t._v(" "),s("ul",[s("li",[t._v("支持基本类型")]),t._v(" "),s("li",[t._v("constructor可以随便改，也不准")])]),t._v(" "),s("p",[s("strong",[t._v("Object.prototype.toString.call([val])")])]),t._v(" "),s("ul",[s("li",[t._v("返回当前实例所属类信息")]),t._v(" "),s("li",[t._v("判断 Target 的类型，单单用 typeof 并无法完全满足，这其实并不是 bug，本质原因是 JS 的万物皆对象的理论。因此要真正完美判断时，我们需要区分对待:")])]),t._v(" "),s("ul",[s("li",[t._v("基本类型(null): 使用 String(null)")]),t._v(" "),s("li",[t._v("基本类型(string / number / boolean / undefined) + function: - 直接使用 typeof即可")]),t._v(" "),s("li",[t._v("其余引用类型(Array / Date / RegExp Error): 调用toString后根据[object XXX]进行判断")])]),t._v(" "),s("h4",{attrs:{id:"_3-数据类型转换"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-数据类型转换"}},[t._v("#")]),t._v(" 3. 数据类型转换")]),t._v(" "),s("p",[t._v("首先我们要知道，在 JS 中类型转换只有三种情况，分别是：")]),t._v(" "),s("ul",[s("li",[t._v("转换为布尔值")]),t._v(" "),s("li",[t._v("转换为数字")]),t._v(" "),s("li",[t._v("转换为字符串\n"),s("img",{attrs:{src:"/images/type2.png",alt:""}})])]),t._v(" "),s("h2",{attrs:{id:"二、apply-call-bind-原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、apply-call-bind-原理"}},[t._v("#")]),t._v(" 二、apply/call/bind 原理")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("方法")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("call")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("apply")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("bind")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("方法参数")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("多个")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("单个数组")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("多个")])]),t._v(" "),s("tr",[s("td",[t._v("方法功能")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("函数调用改变this")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("函数调用改变this")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("函数调用改变this")])]),t._v(" "),s("tr",[s("td",[t._v("返回结果")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("直接执行")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("直接执行")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("返回待执行函数")])])])]),t._v(" "),s("ul",[s("li",[t._v("在浏览器里，在全局范围内this 指向window对象；")]),t._v(" "),s("li",[t._v("在函数中，this永远指向最后调用他的那个对象；")]),t._v(" "),s("li",[t._v("构造函数中，this指向new出来的那个新的对象；")]),t._v(" "),s("li",[t._v("call、apply、bind中的this被强绑定在指定的那个对象上；")]),t._v(" "),s("li",[t._v("箭头函数中this比较特殊,箭头函数this为父作用域的this，不是调用时的this.要知道前四种方式,都是调用时确定,也就是动态的,而箭头函数的this指向是静态的,声明的时候就确定了下来；")]),t._v(" "),s("li",[t._v("apply、call、bind都是js给函数内置的一些API，调用他们可以为函数指定this的执行,同时也可以传参。")])]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("func.call(thisArg, param1, param2, ...)\nfunc.apply(thisArg, [param1,param2,...])\nfunc.bind(thisArg, param1, param2, ...)\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])])])}],!1,null,null,null);n.default=a.exports}}]);