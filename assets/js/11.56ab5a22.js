(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{176:function(s,n,e){"use strict";e.r(n);var a=e(0),t=Object(a.a)({},(function(){var s=this.$createElement;this._self._c;return this._m(0)}),[function(){var s=this,n=s.$createElement,e=s._self._c||n;return e("div",{staticClass:"content"},[e("h2",{attrs:{id:"vue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[s._v("#")]),s._v(" Vue")]),s._v(" "),e("h3",{attrs:{id:"一、-vue3带来的新特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、-vue3带来的新特性"}},[s._v("#")]),s._v(" 一、 vue3带来的新特性")]),s._v(" "),e("p",[e("strong",[s._v("1. 压缩包体积更小")])]),s._v(" "),e("ul",[e("li",[s._v("当前最小化并被压缩的 Vue 运行时大小约为 20kB（2.6.10 版为 22.8kB）。Vue 3.0捆绑包的大小大约会减少一半，即只有10kB！")])]),s._v(" "),e("p",[e("strong",[s._v("2. Object.defineProperty -> Proxy")])]),s._v(" "),e("ul",[e("li",[s._v("Object.defineProperty是一个相对比较昂贵的操作，因为它直接操作对象的属性，颗粒度比较小。将它替换为es6的Proxy，在目标对象之上架了一层拦截，代理的是对象而不是对象的属性。这样可以将原本对对象属性的操作变为对整个对象的操作，颗粒度变大。")]),s._v(" "),e("li",[s._v("javascript引擎在解析的时候希望对象的结构越稳定越好，如果对象一直在变，可优化性降低，proxy不需要对原始对象做太多操作。")])]),s._v(" "),e("p",[e("strong",[s._v("3. Virtual DOM 重构")])]),s._v(" "),e("p",[s._v("vdom的本质是一个抽象层，用javascript描述界面渲染成什么样子。react用jsx，没办法检测出可以优化的动态代码，所以做时间分片，vue中足够快的话可以不用时间分片")]),s._v(" "),e("p",[e("strong",[s._v("4. Performance")]),s._v("\nvue3在性能方面比vue2快了2倍。")]),s._v(" "),e("ul",[e("li",[s._v("重写了虚拟DOM的实现")]),s._v(" "),e("li",[s._v("运行时编译")]),s._v(" "),e("li",[s._v("update性能提高")]),s._v(" "),e("li",[s._v("SSR速度提高")])]),s._v(" "),e("p",[e("strong",[s._v("5. Tree-shaking support")])]),s._v(" "),e("p",[s._v("vue3中的核心api都支持了tree-shaking，这些api都是通过包引入的方式而不是直接在实例化时就注入，只会对使用到的功能或特性进行打包（按需打包），这意味着更多的功能和更小的体积。")]),s._v(" "),e("p",[e("strong",[s._v("6. Composition API")])]),s._v(" "),e("p",[s._v("vue2中，我们一般会采用mixin来复用逻辑代码，用倒是挺好用的，不过也存在一些问题：例如代码来源不清晰、方法属性等冲突。基于此在vue3中引入了Composition API（组合API），使用纯函数分隔复用代码。和React中的hooks的概念很相似")]),s._v(" "),e("p",[e("strong",[s._v("7. 新增的三个组件Fragment、Teleport、Suspense")])]),s._v(" "),e("p",[e("strong",[s._v("Fragment")])]),s._v(" "),e("p",[s._v("在书写vue2时，由于组件必须只有一个根节点，很多时候会添加一些没有意义的节点用于包裹。Fragment组件就是用于解决这个问题的（这和React中的Fragment组件是一样的）。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("\x3c!-- 这意味着现在可以这样写组件了。 --\x3e\n/* App.vue */\n<template>\n  <header>...</header>\n  <main v-bind=\"$attrs\">...</main>\n  <footer>...</footer>\n</template>\n\n<script>\nexport default {};\n<\/script>\n\n\x3c!-- 或者这样 --\x3e\n// app.js\nimport { defineComponent, h, Fragment } from 'vue';\n\nexport default defineComponent({\n    render() {\n        return h(Fragment, {}, [\n            h('header', {}, ['...']),\n            h('main', {}, ['...']),\n            h('footer', {}, ['...']),\n        ]);\n    }\n});\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br"),e("span",{staticClass:"line-number"},[s._v("22")]),e("br"),e("span",{staticClass:"line-number"},[s._v("23")]),e("br"),e("span",{staticClass:"line-number"},[s._v("24")]),e("br"),e("span",{staticClass:"line-number"},[s._v("25")]),e("br")])]),e("p",[e("strong",[s._v("Teleport")])]),s._v(" "),e("p",[s._v("Teleport其实就是React中的Portal。Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。"),e("br"),s._v("\n一个 portal 的典型用例是当父组件有 overflow: hidden 或 z-index 样式时，但你需要子组件能够在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('/* App.vue */\n<template>\n    <div>123</div>\n    <Teleport to="#container">\n        Teleport\n    </Teleport>\n</template>\n\n<script>\nimport { defineComponent } from "vue";\n\nexport default defineComponent({\n    setup() {}\n});\n<\/script>\n\n/* index.html */\n<div id="app"></div>\n<div id="container"></div>\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br")])]),e("p",[e("strong",[s._v("Suspense")])]),s._v(" "),e("p",[s._v("同样的，这和React中的Supense是一样的。"),e("br"),s._v("\nSuspense 让你的组件在渲染之前进行“等待”，并在等待时显示 fallback 的内容")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('// App.vue\n<template>\n    <Suspense>\n        <template #default>\n            <AsyncComponent />\n        </template>\n        <template #fallback>\n            Loading...\n        </template>\n    </Suspense>\n</template>\n\n<script lang="ts">\nimport { defineComponent } from "vue";\nimport AsyncComponent from \'./AsyncComponent.vue\';\n\nexport default defineComponent({\n    name: "App",\n    \n    components: {\n        AsyncComponent\n    }\n});\n<\/script>\n\n// AsyncComponent.vue\n<template>\n    <div>Async Component</div>\n</template>\n\n<script lang="ts">\nimport { defineComponent } from "vue";\n\nconst sleep = () => {\n    return new Promise(resolve => setTimeout(resolve, 1000));\n};\n\nexport default defineComponent({\n    async setup() {\n        await sleep();\n    }\n});\n<\/script>\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br"),e("span",{staticClass:"line-number"},[s._v("22")]),e("br"),e("span",{staticClass:"line-number"},[s._v("23")]),e("br"),e("span",{staticClass:"line-number"},[s._v("24")]),e("br"),e("span",{staticClass:"line-number"},[s._v("25")]),e("br"),e("span",{staticClass:"line-number"},[s._v("26")]),e("br"),e("span",{staticClass:"line-number"},[s._v("27")]),e("br"),e("span",{staticClass:"line-number"},[s._v("28")]),e("br"),e("span",{staticClass:"line-number"},[s._v("29")]),e("br"),e("span",{staticClass:"line-number"},[s._v("30")]),e("br"),e("span",{staticClass:"line-number"},[s._v("31")]),e("br"),e("span",{staticClass:"line-number"},[s._v("32")]),e("br"),e("span",{staticClass:"line-number"},[s._v("33")]),e("br"),e("span",{staticClass:"line-number"},[s._v("34")]),e("br"),e("span",{staticClass:"line-number"},[s._v("35")]),e("br"),e("span",{staticClass:"line-number"},[s._v("36")]),e("br"),e("span",{staticClass:"line-number"},[s._v("37")]),e("br"),e("span",{staticClass:"line-number"},[s._v("38")]),e("br"),e("span",{staticClass:"line-number"},[s._v("39")]),e("br"),e("span",{staticClass:"line-number"},[s._v("40")]),e("br"),e("span",{staticClass:"line-number"},[s._v("41")]),e("br"),e("span",{staticClass:"line-number"},[s._v("42")]),e("br"),e("span",{staticClass:"line-number"},[s._v("43")]),e("br")])]),e("p",[e("strong",[s._v("8. Better TypeScript support")])]),s._v(" "),e("p",[s._v("在vue2中使用过TypesScript的童鞋应该有过体会，写起来实在是有点难受。vue3则是使用ts进行了重写，开发者使用vue3时拥有更好的类型支持和更好的编写体验。")]),s._v(" "),e("h3",{attrs:{id:"二、vue的组件data为什么必须是一个函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、vue的组件data为什么必须是一个函数"}},[s._v("#")]),s._v(" 二、Vue的组件data为什么必须是一个函数?")]),s._v(" "),e("p",[s._v("new Vue是一个单例模式，不会有任何的合并操作，所以根实例不必校验data一定是一个函数。\n组件的data必须是一个函数，是为了防止两个组件的数据产生污染。\n如果都是对象的话，会在合并的时候，指向同一个地址。\n而如果是函数的时候，合并的时候调用，会产生两个空间。")]),s._v(" "),e("h3",{attrs:{id:"三、谈谈vue的性能优化有哪些？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、谈谈vue的性能优化有哪些？"}},[s._v("#")]),s._v(" 三、谈谈Vue的性能优化有哪些？")]),s._v(" "),e("ul",[e("li",[s._v("数据层级不要过深，合理的设置响应式数据")]),s._v(" "),e("li",[s._v("使用数据时，缓存值的结果，不频繁取值")]),s._v(" "),e("li",[s._v("合理设置key")]),s._v(" "),e("li",[s._v("v-show(频繁切换性能高)和v-if的合理使用")]),s._v(" "),e("li",[s._v("控制组件的粒度 -> Vue采用组件级别更新")]),s._v(" "),e("li",[s._v("采用函数式组件 -> 函数式组价开销低")]),s._v(" "),e("li",[s._v("采用异步组件 -> 借助webpack的分包策略")]),s._v(" "),e("li",[s._v("使用keep-alive来缓存组件")]),s._v(" "),e("li",[s._v("虚拟滚动、时间分片等策略")]),s._v(" "),e("li",[s._v("打包优化")])]),s._v(" "),e("h3",{attrs:{id:"四、vue中使用了哪些设计模式？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四、vue中使用了哪些设计模式？"}},[s._v("#")]),s._v(" 四、vue中使用了哪些设计模式？")]),s._v(" "),e("ul",[e("li",[s._v("单例模式：new多次，只有一个实例")]),s._v(" "),e("li",[s._v("工场模式：传入参数就可以创建实例（虚拟节点的创建）")]),s._v(" "),e("li",[s._v("发布订阅模式：eventBus")]),s._v(" "),e("li",[s._v("观察者模式：watch和dep")]),s._v(" "),e("li",[s._v("代理模式：_data属性、proxy、防抖、节流")]),s._v(" "),e("li",[s._v("中介者模式：vuex")]),s._v(" "),e("li",[s._v("策略模式")]),s._v(" "),e("li",[s._v("外观模式")])]),s._v(" "),e("h3",{attrs:{id:"五、说一说keep-alive实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五、说一说keep-alive实现原理"}},[s._v("#")]),s._v(" 五、说一说keep-alive实现原理")]),s._v(" "),e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[s._v("keep-alive")]),s._v(" "),e("p",[s._v("keep-alive组件接受三个属性参数：include、exclude、max")])]),s._v(" "),e("ul",[e("li",[s._v("include 指定需要缓存的组件name集合，参数格式支持String, RegExp, Array。当为字符串的时候，多个组件名称以逗号隔开。")]),s._v(" "),e("li",[s._v("exclude 指定不需要缓存的组件name集合，参数格式和include一样。")]),s._v(" "),e("li",[s._v("max 指定最多可缓存组件的数量,超过数量删除第一个。参数格式支持String、Number。")])]),s._v(" "),e("h4",{attrs:{id:"原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[s._v("#")]),s._v(" 原理")]),s._v(" "),e("ul",[e("li",[s._v("keep-alive实例会缓存对应组件的VNode,如果命中缓存，直接从缓存对象返回对应VNode")]),s._v(" "),e("li",[s._v("LRU（Least recently used） 算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。(墨菲定律：越担心的事情越会发生)")])])])}],!1,null,null,null);n.default=t.exports}}]);