<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS基础 | 月下独酌</title>
    <meta name="description" content="Welcome to my personal site">
    
    
    <link rel="preload" href="/assets/css/0.styles.6aaa91c1.css" as="style"><link rel="preload" href="/assets/js/app.38071572.js" as="script"><link rel="preload" href="/assets/js/10.94da10b1.js" as="script"><link rel="prefetch" href="/assets/js/11.56ab5a22.js"><link rel="prefetch" href="/assets/js/12.816a1587.js"><link rel="prefetch" href="/assets/js/13.5b71f8b5.js"><link rel="prefetch" href="/assets/js/14.5d62c483.js"><link rel="prefetch" href="/assets/js/15.71f4a6cb.js"><link rel="prefetch" href="/assets/js/2.ce1608e6.js"><link rel="prefetch" href="/assets/js/3.7f8423ba.js"><link rel="prefetch" href="/assets/js/4.09dc507d.js"><link rel="prefetch" href="/assets/js/5.b11ebe49.js"><link rel="prefetch" href="/assets/js/6.6ce78cbf.js"><link rel="prefetch" href="/assets/js/7.3ef676a3.js"><link rel="prefetch" href="/assets/js/8.6047b5e7.js"><link rel="prefetch" href="/assets/js/9.01e23169.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6aaa91c1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/images/logo.png" alt="月下独酌" class="logo"> <span class="site-name can-hide">月下独酌</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/accumulate/" class="nav-link">知识库</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">面试题</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/js基础.html" class="nav-link">JS基础</a></li><li class="dropdown-item"><!----> <a href="/interview/HTML.html" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/interview/CSS.html" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/interview/vue.html" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/interview/浏览器.html" class="nav-link">浏览器</a></li><li class="dropdown-item"><!----> <a href="/interview/性能.html" class="nav-link">性能</a></li><li class="dropdown-item"><!----> <a href="/interview/HTTP.html" class="nav-link">HTTP</a></li></ul></div></div><div class="nav-item"><a href="/algorithm/" class="nav-link">作品案例</a></div><div class="nav-item"><a href="/others/" class="nav-link">诗和远方</a></div><div class="nav-item"><a href="/guide.html" class="nav-link">VuePress</a></div><div class="nav-item"><a href="https://github.com/crazynightguichao" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/accumulate/" class="nav-link">知识库</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">面试题</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/js基础.html" class="nav-link">JS基础</a></li><li class="dropdown-item"><!----> <a href="/interview/HTML.html" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/interview/CSS.html" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/interview/vue.html" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/interview/浏览器.html" class="nav-link">浏览器</a></li><li class="dropdown-item"><!----> <a href="/interview/性能.html" class="nav-link">性能</a></li><li class="dropdown-item"><!----> <a href="/interview/HTTP.html" class="nav-link">HTTP</a></li></ul></div></div><div class="nav-item"><a href="/algorithm/" class="nav-link">作品案例</a></div><div class="nav-item"><a href="/others/" class="nav-link">诗和远方</a></div><div class="nav-item"><a href="/guide.html" class="nav-link">VuePress</a></div><div class="nav-item"><a href="https://github.com/crazynightguichao" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>JS基础</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/interview/js%E5%9F%BA%E7%A1%80.html#一、-类型及检测方式" class="sidebar-link">一、 类型及检测方式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/interview/js%E5%9F%BA%E7%A1%80.html#二、apply-call-bind-原理" class="sidebar-link">二、apply/call/bind 原理</a><ul class="sidebar-sub-headers"></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="js基础"><a href="#js基础" class="header-anchor">#</a> JS基础</h1> <h2 id="一、-类型及检测方式"><a href="#一、-类型及检测方式" class="header-anchor">#</a> 一、 类型及检测方式</h2> <h4 id="_1-js内置类型"><a href="#_1-js内置类型" class="header-anchor">#</a> 1. JS内置类型</h4> <p>JavaScript 的数据类型有下图所示
<img src="/images/type.png" alt> <img src="/images/type.png" style="width: 50%; display: block; margin: 0 auto;"></p> <div class="tip custom-block"><p class="custom-block-title">提示</p> <p>其中，前 7 种类型为基础类型，最后 1 种（Object）为引用类型，也是你需要重点关注的，因为它在日常工作中是使用得最频繁，也是需要关注最多技术细节的数据类型</p></div> <ul><li>JavaScript一共有8种数据类型，其中有7种基本数据类型：Undefined、Null、Boolean、Number、String、Symbol（es6新增，表示独一无二的值）和BigInt（es10新增）；</li> <li>1种引用数据类型——Object（Object本质上是由一组无序的名值对组成的）。里面包含 function、Array、Date等。JavaScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一。</li> <li>引用数据类型: 对象Object（包含普通对象-Object，数组对象-Array，正则对象-RegExp，日期对象-Date，数学函数-Math，函数对象-Function）<br> <strong>原始数据类型</strong>：基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。<br> <strong>引用数据类型</strong>：引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念；占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。
<strong>JavaScript 中的数据是如何存储在内存中的？</strong></li></ul> <div class="tip custom-block"><p class="custom-block-title">提示</p> <p>在 JavaScript 中，原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。</p></div> <p>在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间、栈空间、堆空间。其中的代码空间主要是存储可执行代码的，原始类型(Number、String、Null、Undefined、Boolean、Symbol、BigInt)的数据值都是直接保存在“栈”中的，引用类型(Object)的值是存放在“堆”中的。因此在栈空间中(执行上下文)，原始类型存储的是变量的值，而引用类型存储的是其在&quot;堆空间&quot;中的地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手流程。<br>
在编译过程中，如果 JavaScript 引擎判断到一个闭包，也会在堆空间创建换一个“closure(fn)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存闭包中的变量。所以闭包中的变量是存储在“堆空间”中的。<br>
JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。因此需要“栈”和“堆”两种空间。<br></p> <h4 id="_2-数据类型检测"><a href="#_2-数据类型检测" class="header-anchor">#</a> 2. 数据类型检测</h4> <h5 id="（1）typeof"><a href="#（1）typeof" class="header-anchor">#</a> （1）typeof</h5> <div class="tip custom-block"><p class="custom-block-title">提示</p> <p>typeof 对于原始类型来说，除了 null 都可以显示正确的类型</p></div> <div class="language- line-numbers-mode"><pre class="language-text"><code>console.log(typeof 2);            // number
console.log(typeof true);         // boolean
console.log(typeof 'str');        // string
console.log(typeof []);           // object []数组的数据类型在 typeof 中被解释为 object
console.log(typeof function(){}); // function
console.log(typeof {});           // object
console.log(typeof undefined);    // undefined
console.log(typeof null);         // object  null 的数据类型被 typeof 解释为 object
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="tip custom-block"><p class="custom-block-title">提示</p> <p>typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 instanceof</p></div> <h5 id="（2）instanceof"><a href="#（2）instanceof" class="header-anchor">#</a> （2）instanceof</h5> <div class="tip custom-block"><p class="custom-block-title">提示</p> <p>instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype</p></div> <div class="language- line-numbers-mode"><pre class="language-text"><code>console.log(2 instanceof Number);                    // false
console.log(true instanceof Boolean);                // false 
console.log('str' instanceof String);                // false  
console.log([] instanceof Array);                    // true
console.log(function(){} instanceof Function);       // true
console.log({} instanceof Object);                   // true    
// console.log(undefined instanceof Undefined);
// console.log(null instanceof Null);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li>instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；</li> <li>而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 我们也可以试着实现一下 instanceof
function instanceof(left, right) {
    // 获得类型的原型
    let prototype = right.prototype
    // 获得对象的原型
    left = left.__proto__
    // 判断对象的类型是否等于类型的原型
    while (true) {
    	if (left === null)
    		return false
    	if (prototype === left)
    		return true
    	left = left.__proto__
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h5 id="（3）constructor"><a href="#（3）constructor" class="header-anchor">#</a> （3）constructor</h5> <div class="language- line-numbers-mode"><pre class="language-text"><code>console.log((2).constructor === Number); // true
console.log((true).constructor === Boolean); // true
console.log(('str').constructor === String); // true
console.log(([]).constructor === Array); // true
console.log((function() {}).constructor === Function); // true
console.log(({}).constructor === Object); // true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="tip custom-block"><p class="custom-block-title">提示</p> <p>这里有一个坑，如果我创建一个对象，更改它的原型，constructor就会变得不可靠了</p></div> <div class="language- line-numbers-mode"><pre class="language-text"><code>function Fn(){};
 
Fn.prototype=new Array();
 
var f=new Fn();
 
console.log(f.constructor===Fn);    // false
console.log(f.constructor===Array); // true 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h5 id="（4）object-prototype-tostring-call"><a href="#（4）object-prototype-tostring-call" class="header-anchor">#</a> （4）Object.prototype.toString.call()</h5> <div class="tip custom-block"><p class="custom-block-title">提示</p> <p>toString() 是 Object 的原型方法，调用该方法，可以统一返回格式为 “[object Xxx]” 的字符串，其中 Xxx 就是对象的类型。对于 Object 对象，直接调用 toString() 就能返回 [object Object]；而对于其他对象，则需要通过 call 来调用，才能返回正确的类型信息。我们来看一下代码。</p></div> <div class="language- line-numbers-mode"><pre class="language-text"><code>Object.prototype.toString({})       // &quot;[object Object]&quot;
Object.prototype.toString.call({})  // 同上结果，加上call也ok
Object.prototype.toString.call(1)    // &quot;[object Number]&quot;
Object.prototype.toString.call('1')  // &quot;[object String]&quot;
Object.prototype.toString.call(true)  // &quot;[object Boolean]&quot;
Object.prototype.toString.call(function(){})  // &quot;[object Function]&quot;
Object.prototype.toString.call(null)   //&quot;[object Null]&quot;
Object.prototype.toString.call(undefined) //&quot;[object Undefined]&quot;
Object.prototype.toString.call(/123/g)    //&quot;[object RegExp]&quot;
Object.prototype.toString.call(new Date()) //&quot;[object Date]&quot;
Object.prototype.toString.call([])       //&quot;[object Array]&quot;
Object.prototype.toString.call(document)  //&quot;[object HTMLDocument]&quot;
Object.prototype.toString.call(window)   //&quot;[object Window]&quot;

// 从上面这段代码可以看出，Object.prototype.toString.call() 可以很好地判断引用类型，
甚至可以把 document 和 window 都区分开来。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><ul><li>实现一个全局通用的数据类型判断方法，来加深你的理解，代码如下</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>function getType(obj){
  let type  = typeof obj;
  if (type !== &quot;object&quot;) {    // 先进行typeof判断，如果是基础数据类型，直接返回
    return type;
  }
  // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果
  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, '$1');  // 注意正则中间有个空格
}
/* 代码验证，需要注意大小写，哪些是typeof判断，哪些是toString判断？思考下 */
getType([])     // &quot;Array&quot; typeof []是object，因此toString返回
getType('123')  // &quot;string&quot; typeof 直接返回
getType(window) // &quot;Window&quot; toString返回
getType(null)   // &quot;Null&quot;首字母大写，typeof null是object，需toString来判断
getType(undefined)   // &quot;undefined&quot; typeof 直接返回
getType()            // &quot;undefined&quot; typeof 直接返回
getType(function(){}) // &quot;function&quot; typeof能判断，因此首字母小写
getType(/123/g)      //&quot;RegExp&quot; toString返回
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h5 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h5> <p><strong>typeof</strong></p> <ul><li>直接在计算机底层基于数据类型的值（二进制）进行检测</li> <li>typeof null为object 原因是对象存在在计算机中，都是以000开始的二进制存储，所以检测出来的结果是对象</li> <li>typeof 普通对象/数组对象/正则对象/日期对象 都是object</li> <li>typeof NaN === 'number'</li></ul> <p><strong>instanceof</strong></p> <ul><li>检测当前实例是否属于这个类的</li> <li>底层机制：只要当前类出现在实例的原型上，结果都是true</li> <li>不能检测基本数据类型</li></ul> <p><strong>constructor</strong></p> <ul><li>支持基本类型</li> <li>constructor可以随便改，也不准</li></ul> <p><strong>Object.prototype.toString.call([val])</strong></p> <ul><li>返回当前实例所属类信息</li> <li>判断 Target 的类型，单单用 typeof 并无法完全满足，这其实并不是 bug，本质原因是 JS 的万物皆对象的理论。因此要真正完美判断时，我们需要区分对待:</li></ul> <ul><li>基本类型(null): 使用 String(null)</li> <li>基本类型(string / number / boolean / undefined) + function: - 直接使用 typeof即可</li> <li>其余引用类型(Array / Date / RegExp Error): 调用toString后根据[object XXX]进行判断</li></ul> <h4 id="_3-数据类型转换"><a href="#_3-数据类型转换" class="header-anchor">#</a> 3. 数据类型转换</h4> <p>首先我们要知道，在 JS 中类型转换只有三种情况，分别是：</p> <ul><li>转换为布尔值</li> <li>转换为数字</li> <li>转换为字符串
<img src="/images/type2.png" alt></li></ul> <h2 id="二、apply-call-bind-原理"><a href="#二、apply-call-bind-原理" class="header-anchor">#</a> 二、apply/call/bind 原理</h2> <table><thead><tr><th>方法</th> <th style="text-align:center">call</th> <th style="text-align:center">apply</th> <th style="text-align:center">bind</th></tr></thead> <tbody><tr><td>方法参数</td> <td style="text-align:center">多个</td> <td style="text-align:center">单个数组</td> <td style="text-align:center">多个</td></tr> <tr><td>方法功能</td> <td style="text-align:center">函数调用改变this</td> <td style="text-align:center">函数调用改变this</td> <td style="text-align:center">函数调用改变this</td></tr> <tr><td>返回结果</td> <td style="text-align:center">直接执行</td> <td style="text-align:center">直接执行</td> <td style="text-align:center">返回待执行函数</td></tr></tbody></table> <ul><li>在浏览器里，在全局范围内this 指向window对象；</li> <li>在函数中，this永远指向最后调用他的那个对象；</li> <li>构造函数中，this指向new出来的那个新的对象；</li> <li>call、apply、bind中的this被强绑定在指定的那个对象上；</li> <li>箭头函数中this比较特殊,箭头函数this为父作用域的this，不是调用时的this.要知道前四种方式,都是调用时确定,也就是动态的,而箭头函数的this指向是静态的,声明的时候就确定了下来；</li> <li>apply、call、bind都是js给函数内置的一些API，调用他们可以为函数指定this的执行,同时也可以传参。</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>func.call(thisArg, param1, param2, ...)
func.apply(thisArg, [param1,param2,...])
func.bind(thisArg, param1, param2, ...)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.38071572.js" defer></script><script src="/assets/js/10.94da10b1.js" defer></script>
  </body>
</html>
